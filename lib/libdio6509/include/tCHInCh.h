// Copyright (c) 2012 National Instruments.
// All rights reserved.
// License: NATIONAL INSTRUMENTS SOFTWARE LICENSE AGREEMENT
//   Refer to "MHDDK License Agreement.pdf" in the root of this distribution.

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef ___tCHInCh_h___
#define ___tCHInCh_h___

// includes
#include "osiTypes.h"
#include "osiBus.h"

#ifndef ___tCHInChValues_h___
#include "tCHInChValues.h"
#endif

#ifndef nNIMXRegisterMap120_mBuildFieldId

// Algorithm:
//    Move lowermost 5 bits (4 through 0) of field id to uppermost 5 bits (31
//          through 27)
//    Move bit 5 of field id to bit 26
//    Move bit 6 of field id to bit 25
//    OR in the register id (which is allowed the remaining bits)
//
// Why not move the lowermost 7 bits directly to the uppermost 7 bits? Because
// we originally moved only the lowermost 5, and for backwards compatibility,
// we can't change where those 5 bits end up.
//
// For future expansion purposes, the bits beyond the first 5 are put in reverse
// order in the resulting combined id.
#define nNIMXRegisterMap120_mBuildFieldId(fieldId, regId) \
   ( \
     ((fieldId) << 27) | \
     ((((fieldId) >> 5) & 0x1) << 26) | \
     ((((fieldId) >> 6) & 0x1) << 25) | \
     (regId) \
   )

#endif

#ifndef nNIMXRegisterMap120_mExtractFieldId

// Algorithm: (basically the reverse of mBuildFieldId)
//    Move uppermost 5 bits (31 through 27) to lowermost 5 bits (4 through 0)
//    Move 26th bit to bit 5 (right-shifting by (26 - 5) is like right-shifting
//          by 26 then left-shifting by 5, but it's more efficient)
//    Move 25th bit to bit 6
#define nNIMXRegisterMap120_mExtractFieldId(id) \
   (unsigned int) \
   ( \
     (((id) >> 27) & 0x1F) | \
     (((id) & (0x1 << 26)) >> (26 - 5)) | \
     (((id) & (0x1 << 25)) >> (25 - 6)) \
   )

#endif

class tCHInCh
{
public:
   //---------------------------------------------------------------------------
   // IO Strategies
   //---------------------------------------------------------------------------
   class tReg32IODirect32
   {
   public:
      inline void write(
         tBusSpaceReference addrSpace,
         u32 offset,
         u32 value,
         nMDBG::tStatus2* statusChain = NULL);

      inline u32 read(
         tBusSpaceReference addrSpace,
         u32 offset,
         nMDBG::tStatus2* statusChain = NULL);
   };

   //---------------------------------------------------------------------------
   // CHInCh_Identification_Register
   //---------------------------------------------------------------------------
   class tCHInCh_Identification_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x0,
         kId     = 0
      };
      tCHInCh_Identification_Register();


      typedef enum {
         kRegisterId                          = 0,
         kIDId                             = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tCHInCh_Identification_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tCHInCh_Identification_Register& setID(nCHInCh::tCHInCh_Signature_t fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline nCHInCh::tCHInCh_Signature_t getID(nMDBG::tStatus2* statusChain = NULL) const;

      inline nCHInCh::tCHInCh_Signature_t readID(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tCHInCh_Identification_Register(const tCHInCh_Identification_Register&);
      tCHInCh_Identification_Register& operator=(const tCHInCh_Identification_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt_Mask_Register
   //---------------------------------------------------------------------------
   class tInterrupt_Mask_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x5c,
         kId     = 1
      };
      tInterrupt_Mask_Register();


      typedef enum {
         kRegisterId                          = 0,
         kClear_STC3_IntId                 = 5,
         kSet_STC3_IntId                   = 6,
         kClear_CPU_IntId                  = 14,
         kSet_CPU_IntId                    = 15,
         kMaxFieldId                          = 15
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tInterrupt_Mask_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tInterrupt_Mask_Register& setClear_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getClear_STC3_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClear_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readClear_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setSet_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSet_STC3_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSet_STC3_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSet_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setClear_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getClear_CPU_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeClear_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readClear_CPU_Int(nMDBG::tStatus2* statusChain = NULL);

      inline tInterrupt_Mask_Register& setSet_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSet_CPU_Int(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSet_CPU_Int(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSet_CPU_Int(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt_Mask_Register(const tInterrupt_Mask_Register&);
      tInterrupt_Mask_Register& operator=(const tInterrupt_Mask_Register&);

   };

   //---------------------------------------------------------------------------
   // Interrupt_Status_Register
   //---------------------------------------------------------------------------
   class tInterrupt_Status_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x60,
         kId     = 2
      };
      tInterrupt_Status_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSTC3_IntId                       = 4,
         kExternalId                       = 11,
         kAdditional_IntId                 = 12,
         kIntId                            = 13,
         kMaxFieldId                          = 13
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline u32 readSTC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readExternal(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readAdditional_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readInt(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tInterrupt_Status_Register(const tInterrupt_Status_Register&);
      tInterrupt_Status_Register& operator=(const tInterrupt_Status_Register&);

   };

   //---------------------------------------------------------------------------
   // Volatile_Interrupt_Status_Register
   //---------------------------------------------------------------------------
   class tVolatile_Interrupt_Status_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x68,
         kId     = 3
      };
      tVolatile_Interrupt_Status_Register();


      typedef enum {
         kRegisterId                          = 0,
         kVol_STC3_IntId                   = 4,
         kVol_ExternalId                   = 11,
         kVol_Additional_IntId             = 12,
         kVol_IntId                        = 13,
         kMaxFieldId                          = 13
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline u32 readVol_STC3_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_External(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_Additional_Int(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readVol_Int(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      tRegisterMap* _regMap;

      // Usage guidelines
      tVolatile_Interrupt_Status_Register(const tVolatile_Interrupt_Status_Register&);
      tVolatile_Interrupt_Status_Register& operator=(const tVolatile_Interrupt_Status_Register&);

   };

   //---------------------------------------------------------------------------
   // Scrap_Register_t
   //---------------------------------------------------------------------------
   class tScrap_Register_t : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      const u32 kOffset;
      const u32 kId;

      tScrap_Register_t(u32 offset, u32 id);
      tScrap_Register_t();
      void initialize(u32 offset, u32 id);


      typedef enum {
         kRegisterId                          = 0,
         kSDATAId                          = 1,
         kMaxFieldId                          = 1
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Dirty Tracking
      inline tBoolean isDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
      inline void markClean(nMDBG::tStatus2* statusChain = NULL);

      // Register Accessors (Compile-time selectable)
      inline tScrap_Register_t& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void flush(nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void writeRegister(u32 value, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tScrap_Register_t& setSDATA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSDATA(nMDBG::tStatus2* statusChain = NULL) const;

      inline void writeSDATA(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL, tBoolean force = kTrue);

      inline u32 readSDATA(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tScrap_Register_t(const tScrap_Register_t&);
      tScrap_Register_t& operator=(const tScrap_Register_t&);

   };

   //---------------------------------------------------------------------------
   // PCI_SubSystem_ID_Access_Register
   //---------------------------------------------------------------------------
   class tPCI_SubSystem_ID_Access_Register : public tReg32IODirect32
   {
   public:
      typedef tReg32IODirect32 tIOStrategy;
      typedef tCHInCh tRegisterMap;

      enum {
         kOffset = 0x10ac,
         kId     = 5
      };
      tPCI_SubSystem_ID_Access_Register();


      typedef enum {
         kRegisterId                          = 0,
         kSubSystem_Vendor_IDId            = 1,
         kSubSystem_Product_IDId           = 2,
         kMaxFieldId                          = 2
      } tId;

      inline tRegisterMap* registerMap(void);
      inline void setRegisterMap(tRegisterMap* pRegMap);


      // Register Accessors (Compile-time selectable)
      inline tPCI_SubSystem_ID_Access_Register& setRegister(u32 value, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getRegister(nMDBG::tStatus2* statusChain = NULL) const;

      inline void refresh(nMDBG::tStatus2* statusChain = NULL);

      inline u32 readRegister(nMDBG::tStatus2* statusChain = NULL);

      // Field Accessors (Compile-time selectable)
      inline tPCI_SubSystem_ID_Access_Register& setSubSystem_Vendor_ID(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSubSystem_Vendor_ID(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSubSystem_Vendor_ID(nMDBG::tStatus2* statusChain = NULL);

      inline tPCI_SubSystem_ID_Access_Register& setSubSystem_Product_ID(u32 fieldValue, nMDBG::tStatus2* statusChain = NULL);
      inline u32 getSubSystem_Product_ID(nMDBG::tStatus2* statusChain = NULL) const;

      inline u32 readSubSystem_Product_ID(nMDBG::tStatus2* statusChain = NULL);

      // Run-time selectable Register/Field Accessors
   private:
      u32 _softCopy;

      tRegisterMap* _regMap;

      // Usage guidelines
      tPCI_SubSystem_ID_Access_Register(const tPCI_SubSystem_ID_Access_Register&);
      tPCI_SubSystem_ID_Access_Register& operator=(const tPCI_SubSystem_ID_Access_Register&);

   };

   //----------------------------------------
   // Register Array Sizes
   //----------------------------------------
   enum {
      kScrap_RegisterArraySize = 1
   };

   //---------------------------------------------------------------------------
   // CHInCh_Identification_Register
   //---------------------------------------------------------------------------
   tCHInCh_Identification_Register CHInCh_Identification_Register;

   //---------------------------------------------------------------------------
   // Interrupt_Mask_Register
   //---------------------------------------------------------------------------
   tInterrupt_Mask_Register Interrupt_Mask_Register;

   //---------------------------------------------------------------------------
   // Interrupt_Status_Register
   //---------------------------------------------------------------------------
   tInterrupt_Status_Register Interrupt_Status_Register;

   //---------------------------------------------------------------------------
   // Volatile_Interrupt_Status_Register
   //---------------------------------------------------------------------------
   tVolatile_Interrupt_Status_Register Volatile_Interrupt_Status_Register;

   //---------------------------------------------------------------------------
   // Scrap_Register
   //---------------------------------------------------------------------------
   tScrap_Register_t Scrap_Register[kScrap_RegisterArraySize];

   //---------------------------------------------------------------------------
   // PCI_SubSystem_ID_Access_Register
   //---------------------------------------------------------------------------
   tPCI_SubSystem_ID_Access_Register PCI_SubSystem_ID_Access_Register;

   //---------------------------------------------------------------------------
   // Register Groups
   //---------------------------------------------------------------------------

   //----------------------------------------
   // Register/Field Ids
   //----------------------------------------
   typedef enum {
      kCHInCh_Identification_RegisterId   = 0,
      kIDId                             = nNIMXRegisterMap120_mBuildFieldId(tCHInCh_Identification_Register::kIDId, kCHInCh_Identification_RegisterId),

      kInterrupt_Mask_RegisterId        = 1,
      kClear_STC3_IntId                 = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kClear_STC3_IntId, kInterrupt_Mask_RegisterId),
      kSet_STC3_IntId                   = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kSet_STC3_IntId, kInterrupt_Mask_RegisterId),
      kClear_CPU_IntId                  = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kClear_CPU_IntId, kInterrupt_Mask_RegisterId),
      kSet_CPU_IntId                    = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Mask_Register::kSet_CPU_IntId, kInterrupt_Mask_RegisterId),

      kInterrupt_Status_RegisterId      = 2,
      kSTC3_IntId                       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kSTC3_IntId, kInterrupt_Status_RegisterId),
      kExternalId                       = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kExternalId, kInterrupt_Status_RegisterId),
      kAdditional_IntId                 = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kAdditional_IntId, kInterrupt_Status_RegisterId),
      kIntId                            = nNIMXRegisterMap120_mBuildFieldId(tInterrupt_Status_Register::kIntId, kInterrupt_Status_RegisterId),

      kVolatile_Interrupt_Status_RegisterId       = 3,
      kVol_STC3_IntId                   = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_STC3_IntId, kVolatile_Interrupt_Status_RegisterId),
      kVol_ExternalId                   = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_ExternalId, kVolatile_Interrupt_Status_RegisterId),
      kVol_Additional_IntId             = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_Additional_IntId, kVolatile_Interrupt_Status_RegisterId),
      kVol_IntId                        = nNIMXRegisterMap120_mBuildFieldId(tVolatile_Interrupt_Status_Register::kVol_IntId, kVolatile_Interrupt_Status_RegisterId),

      kScrap_Register0Id                = 4,
      kScrap0SDATAId                    = nNIMXRegisterMap120_mBuildFieldId(tScrap_Register_t::kSDATAId, kScrap_Register0Id),

      kPCI_SubSystem_ID_Access_RegisterId     = 5,
      kSubSystem_Vendor_IDId            = nNIMXRegisterMap120_mBuildFieldId(tPCI_SubSystem_ID_Access_Register::kSubSystem_Vendor_IDId, kPCI_SubSystem_ID_Access_RegisterId),
      kSubSystem_Product_IDId           = nNIMXRegisterMap120_mBuildFieldId(tPCI_SubSystem_ID_Access_Register::kSubSystem_Product_IDId, kPCI_SubSystem_ID_Access_RegisterId),


      kMaxRegisterId = 5

   } tId;

   tCHInCh(tBusSpaceReference addrSpace, nMDBG::tStatus2* statusChain = NULL);
   tCHInCh();
   void initialize(tBusSpaceReference addrSpace, u32 addressOffset, nMDBG::tStatus2* statusChain = NULL);
   void reset(nMDBG::tStatus2* statusChain = NULL);
   virtual ~tCHInCh();

   inline tBusSpaceReference getBusSpaceReference(void) const;

   inline void setAddressOffset(u32 value, nMDBG::tStatus2* statusChain = NULL);
   inline u32  getAddressOffset(nMDBG::tStatus2* statusChain = NULL);
   inline tBoolean isDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markDirty(tId id, nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(tId id, nMDBG::tStatus2* statusChain = NULL);

   inline void markDirty(nMDBG::tStatus2* statusChain = NULL);
   inline void markClean(nMDBG::tStatus2* statusChain = NULL);

private:
   void _initialize(nMDBG::tStatus2* statusChain = NULL);
   tBusSpaceReference _addrSpace;
   u32 _addressOffset;
   u8 _dirtyVector[6];

};

#ifndef ___tCHInCh_ipp___
#ifndef ___tCHInCh_h_no_inline___
#include "tCHInCh.ipp"
#endif

#endif

#endif


// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// This file is autogenerated!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

